"""
fstab generation module.

This module handles generating optimized fstab entries for the target system.
Refactored for better readability and separation of concerns.
"""
import os
import logging
from typing import Dict, Any, List
from pathlib import Path

from architect.utils.command import CommandRunner, SimulationMode
from architect.utils.format import TermColors, colorize
from architect.utils.types import PartitionTable, MountOptions
from architect.core.exceptions import FstabError
from architect.config import create_etc_directory

logger = logging.getLogger('architect')


def _get_partition_identifier(partition_path: str, id_type: str, cmd_runner: CommandRunner) -> str:
    """
    Get a partition identifier (UUID or PARTUUID) for use in fstab.
    
    Args:
        partition_path: Path to the partition device
        id_type: Type of identifier to get ('UUID' or 'PARTUUID')
        cmd_runner: CommandRunner instance for executing commands
        
    Returns:
        The partition identifier as a string
    """
    try:
        result = cmd_runner.run(["blkid", "-s", id_type, "-o", "value", partition_path])
        return result.stdout.strip()
    except Exception as e:
        logger.error(colorize(f"Failed to get {id_type} for {partition_path}: {e}", 
                             TermColors.ERROR, cmd_runner.colored_output))
        raise


def generate_fstab(partitions: PartitionTable, mount_options: MountOptions, args: Any, cmd_runner: CommandRunner) -> None:
    """
    Generate fstab in target directory.
    
    Args:
        partitions: Dict mapping partition roles to device paths
        mount_options: Dict mapping mount points to their mount options
        args: Command line arguments
        cmd_runner: CommandRunner instance for executing commands
        
    Raises:
        FstabError: If there's an error in fstab generation
    """
    if not args.generate_fstab:
        return
    
    target = args.target
    target_path = Path(target)
    etc_path = target_path / "etc"
    fstab_path = etc_path / "fstab"
    
    # Create etc directory if it doesn't exist
    create_etc_directory(target_path, cmd_runner)
    
    logger.info(colorize(f"Generating fstab at {fstab_path}", 
                        TermColors.INFO, cmd_runner.colored_output))
    
    try:
        # Get device identifiers
        efi_partuuid = _get_partition_identifier(partitions["efi"], "PARTUUID", cmd_runner)
        boot_partuuid = _get_partition_identifier(partitions["boot"], "PARTUUID", cmd_runner)
        system_uuid = _get_partition_identifier(partitions["system"], "UUID", cmd_runner)
        
        # Build fstab content
        fstab_content = []
        fstab_content.append("# /etc/fstab: static file system information.")
        fstab_content.append("# Generated by architect")
        fstab_content.append("#")
        fstab_content.append("# <file system> <mount point> <type> <options> <dump> <pass>")
        
        # Include LUKS device if using software encryption
        if "system_crypt" in partitions:
            crypt_partuuid = _get_partition_identifier(partitions["system_crypt"], "PARTUUID", cmd_runner)
            luks_name = os.path.basename(partitions["system"])
            fstab_content.append("# LUKS encrypted partition")
            fstab_content.append("")
        
        # Define all subvolumes and mount points
        subvolumes = {
            # Subvolume: mount point
            "@": "/",
            "@home": "/home",
            "@opt": "/opt",
            "@root": "/root",
            "@srv": "/srv",
            "@tmp": "/tmp",
            "@usr": "/usr",
            "@var": "/var",
            "@var_log": "/var/log",
            "@var_tmp": "/var/tmp"
        }
        
        # Add root entry
        root_options = mount_options["/"]
        if root_options == "defaults":
            root_options = "subvol=@"
        else:
            root_options = f"subvol=@,{root_options}"
        fstab_content.append(f"UUID={system_uuid} / btrfs {root_options} 0 0")
        
        # Add boot entry
        boot_options = mount_options["/boot"]
        fstab_content.append(f"PARTUUID={boot_partuuid} /boot ext4 {boot_options} 0 2")
        
        # Add EFI entry
        efi_options = mount_options["/boot/efi"]
        fstab_content.append(f"PARTUUID={efi_partuuid} /boot/efi vfat {efi_options} 0 2")
        
        # Add other subvolumes
        for subvol, mountpoint in subvolumes.items():
            # Skip root as it's already added
            if subvol == "@":
                continue
                
            options = mount_options[mountpoint]
            if options == "defaults":
                options = f"subvol={subvol}"
            else:
                options = f"subvol={subvol},{options}"
                
            fstab_content.append(f"UUID={system_uuid} {mountpoint} btrfs {options} 0 0")
        
        # Add proc with hidepid=2 if in hardened mode
        if args.hardened:
            fstab_content.append("")
            fstab_content.append("# Secured /proc mount with process hiding")
            fstab_content.append("proc /proc proc hidepid=2,gid=proc 0 0")
        
        # Write fstab or display it in simulation mode
        if cmd_runner.simulation_mode == SimulationMode.SIMULATE:
            logger.info("Would write the following to fstab:")
            for line in fstab_content:
                logger.info(f"  {line}")
        else:
            with open(fstab_path, "w") as f:
                f.write("\n".join(fstab_content) + "\n")
        
        logger.info(colorize("fstab generated successfully", 
                            TermColors.SUCCESS, cmd_runner.colored_output))
                            
    except Exception as e:
        error_msg = f"Failed to generate fstab: {e}"
        logger.error(colorize(error_msg, TermColors.ERROR, cmd_runner.colored_output))
        raise FstabError(error_msg)